
import torch
import torch.nn.functional as F
from torchvision import transforms
from PIL import Image
import timm
import json
from pathlib import Path
from ml_models.plant_disease.remedy_dict import final_remedy_dict

# -------------------------------
# Confidence calibration (Temperature Scaling)
# -------------------------------
def softmax_with_temperature(logits, T=0.5):
    """
    T < 1.0 increases confidence
    T = 1.0 normal softmax
    """
    return torch.softmax(logits / T, dim=1)

# -------------------------------
# CONFIG
# -------------------------------
BASE_DIR = Path(__file__).resolve().parent
MODEL_PATH = BASE_DIR / "checkpoints" / "efficientnet_b0_best.pth"
CLASS_MAP_PATH = BASE_DIR / "class_mapping.json"                 # autogenerated mapping
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"

IMAGE_SIZE = 224

PEST_ID_TO_NAME = {
    "pest_0":  "Aphids",
    "pest_1":  "Whiteflies",
    "pest_2":  "Thrips",
    "pest_3":  "Leaf Miners",
    "pest_4":  "Caterpillars",
    "pest_5":  "Armyworm",
    "pest_6":  "Cutworm",
    "pest_7":  "Stem Borer",
    "pest_8":  "Fruit Fly",
    "pest_9":  "Weevil",

    "pest_10": "Grasshopper",
    "pest_11": "Beetle",
    "pest_12": "Mite",
    "pest_13": "Mealybug",
    "pest_14": "Scale Insect",
    "pest_15": "Leafhopper",
    "pest_16": "Planthopper",
    "pest_17": "Earwig",
    "pest_18": "Termite",
    "pest_19": "Flea Beetle",

    "pest_20": "Slug",
    "pest_21": "Snail",
    "pest_22": "Wireworm",
    "pest_23": "Root Maggot"
}


# -------------------------------
# Load class mapping
# -------------------------------
with open(CLASS_MAP_PATH, "r") as f:
    idx_to_class = json.load(f)

# -------------------------------
# Preprocessing transform
# -------------------------------
infer_transform = transforms.Compose([
    transforms.Resize((IMAGE_SIZE, IMAGE_SIZE)),
    transforms.ToTensor(),
])

# -------------------------------
# Load model
# -------------------------------
num_classes = len(idx_to_class)

model = timm.create_model("efficientnet_b0", pretrained=False, num_classes=num_classes)
state = torch.load(MODEL_PATH, map_location=DEVICE)
model.load_state_dict(state["model_state_dict"])
model.to(DEVICE)
model.eval()

# -------------------------------
# Helper: Get remedy
# -------------------------------
def get_remedy(class_name):
    return final_remedy_dict.get(class_name, final_remedy_dict["_default"])

# -------------------------------
# Predict function
# -------------------------------
def predict(image_path):
    img = Image.open(image_path).convert("RGB")
    img_t = infer_transform(img).unsqueeze(0).to(DEVICE)

    with torch.no_grad():
        logits = model(img_t)
        probs = softmax_with_temperature(logits, T=0.5)[0]

    # Get Top-3 predictions
    topk = torch.topk(probs, k=3)
    top_classes = []
    top_confidences = []

    # Convert indices to class names and calculate normalized confidence
    total_topk_prob = topk.values.sum().item()
    for idx, val in zip(topk.indices, topk.values):
        raw_class = idx_to_class[str(idx.item())]

        # Convert pest IDs to human-readable names
        if raw_class.startswith("pest_"):
            display_class = PEST_ID_TO_NAME.get(raw_class, raw_class)
        else:
            display_class = (raw_class.replace("pv__", "").replace("pd__", "").replace("__","").replace("_","").title())

        top_classes.append(display_class)
        top_confidences.append((val / total_topk_prob).item())

    if top_confidences[0] < 0.3:
        note = "Low confidence prediction. Please upload a clearer image or inspect manually."
    else:
        note = "Prediction confident."


    remedy = get_remedy(idx_to_class[str(topk.indices[0].item())])

    return {
        "class": top_classes,
        "confidence": top_confidences,
        "remedy": remedy,
        "note": note
    }

# -------------------------------
# Example run
# -------------------------------
if __name__ == "__main__":
    test_image = r"D:/vscode/agroai/Backend/ml_models/plant_disease/Cherry leaf (1).jpg"  # change to your test image
    result = predict(test_image)
    print("\nPrediction Result:")
    print(json.dumps(result, indent=4))
